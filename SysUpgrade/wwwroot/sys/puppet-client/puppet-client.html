<!-- puppet-polymer-client version: 1.0.4 | MIT License -->

<link rel="import" href="../polymer/polymer.html">
<!-- <link rel="import" href="iron-request.html"> -->

<!-- include PuppetJs with dependencies -->
<script src="../fast-json-patch/src/json-patch-duplex.js"></script>
<script src="../json-patch-queue/src/json-patch-queue.js"></script>
<script src="../json-patch-ot-agent/src/json-patch-ot-agent.js"></script>
<script src="../json-patch-ot/src/json-patch-ot.js"></script>
<script src="../PuppetJs/src/puppet.js"></script>
<script src="../PuppetJs/src/puppet-dom.js"></script>

<!--
The Polymer version of `puppet-client` element binds [PuppetJs](https://github.com/PuppetJs/PuppetJs) with [Polymer's template binding](https://www.polymer-project.org/1.0/docs/devguide/templates.html).
That keeps your Polymer app, or just `dom-bind` template in sync with any server-side
data-model using Puppet & [JSON Patch](https://tools.ietf.org/html/rfc6902) flow.

You get three-way data binding server - JS - HTML, kept in flawless sync.

    <puppet-client
        obj="{{model}}"></puppet-client>


It establishes the PuppetJs connection when attached. All the changes made
in browser are sent to the server via WebSocket or HTTP, as
[JSON Patch](https://tools.ietf.org/html/rfc6902)es.
All the changes from server are also received and propagated to your HTML.

@demo demo/index.html
-->

<script>
(function() {
    'use strict';


    Polymer({

        is: 'puppet-client',

        /**
         * Fired when patch gets applied
         *
         * @event patch-applied
         */
        /**
         * Fired when patch gets applied
         *
         * @event patchreceived
         */
        /**
         * Fired when patch gets applied
         *
         * @event patchsent
         */
        /**
         * Fired when patch gets applied
         *
         * @event socketstatechanged
         */
        /**
         * Fired when patch gets applied
         *
         * @event connectionerror
         */


        hostAttributes: {
            hidden: true
        },

        properties: {
            /**
             * The remote's URL
             */
            remoteUrl: {
                type: String
            },
            /**
             * Regular expression with local properties to ignore
             * @see [PuppetJS.ignoreAdd](https://github.com/PuppetJs/PuppetJs#ignoring-local-changes-ignoreadd).
             * Should be given in string format, like `"_.+"`.
             */
            ignoreAdd: {
                type: RegExp,
                value: /.*/,
				observer: '_ignoreAddChanged'
            },
            /**
             * Set to `false` to disable WebSocket (use HTTP)
             */
            useWebSocket: {
                type: Boolean,
                value: true
            },
            /**
             * Set to true to enable debugging mode
             */
            debug: {
                type: Boolean,
                value: false
            },
            /**
             * {JSONPointer} local version path, set to falsy do disable Versioned JSON Patch communication
             */
            localVersionPath: {
                type: String,
                value: '/_ver#c$'
            },
            /**
             * {JSONPointer} remote version path, set it to falsy to disable Double Versioned JSON Patch communication
             */
            remoteVersionPath: {
                type: String,
                value: '/_ver#s'
            },
            /**
             * `false` to disable OT
             */
            ot: {
                type: Boolean,
                value: true
            },
            /**
             * `true` to enable purist mode of OT
             */
            purity: {
                type: Boolean,
                value: false
            },
            /**
             *  DOM node to listen to (see [PuppetDOM listenTo attribute](https://github.com/PuppetJs/PuppetJs#puppetdom))
             */
            listenTo: {
                type: String
            },
            /**
             *  Interval in seconds between ping patches, `0` - disable ping patches
             */
            pingInterval: {
                type: Number,
                value: '60'
            },

            /**
             * Object that will be synced
             */
            obj: {
                type: Object,
                notify: true,
                value: function() {
                    return {};
                }
            },

            /**
             * Path to given obj
             */
            path: {
                type: String,
                value: '/'
            },


            // /**
            //  * If true, automatically performs an Ajax request when either `url` or
            //  * `params` changes.
            //  */
            // auto: {
            //     type: Boolean,
            //     value: false
            // },

        },

        /**
         * Creates an instance of Puppet according to given params, attaches it to .pupet property
         *
         */
        attached: function() {

            var whereToBind = this.getAttribute("ref");
            var listenTo = this.listenTo;
            var pingInterval = this.pingInterval / 1;
            var me = this;

            if (listenTo) {
                listenTo = typeof listenTo == "string" ? document.getElementById(listenTo) : listenTo;
            }

            this.puppet = new PuppetDOM({
                remoteUrl: this.remoteUrl,
                pingInterval: pingInterval,
                listenTo: listenTo,
                obj: this.obj,
                useWebSocket: this.useWebSocket,
                ignoreAdd: this.ignoreAdd,
                debug: this.debug,
                onLocalChange: this.onLocalChange.bind(this),
                onPatchReceived: this.onPatchReceived.bind(this),
                onPatchSent: this.onPatchSent.bind(this),
                onSocketStateChanged: this.onSocketStateChanged.bind(this),
                onConnectionError: this.onConnectionError.bind(this),

                localVersionPath: this.localVersionPath,
                remoteVersionPath: this.remoteVersionPath,
                ot: this.ot,
                purity: this.purity,
                jsonpatch: {
                    apply: this.applyJSONPatch.bind(this),
                    observe: jsonpatch.observe.bind(this),
                    unobserve: jsonpatch.unobserve.bind(this),
                    validate: this.validateJSONPatch.bind(this)
                },
                callback: function() {
                    if (whereToBind) {
                        this.bindTo(whereToBind);
                    }
                }.bind(this)
            });
            // this.puppet.addEventListener('patch-applied', this.notifyChange);

            this.network = this.puppet.network;
            this.morphUrl = this.puppet.morphUrl.bind(this.puppet);
        },
        bindTo: function(element) {
            // use node id or node itself;
            element = typeof element == "string" ? document.getElementById(element) : element;
            element.model = this.obj;
            this.bound = true;
        },
        propagateDomBind: function(sequence) {
            var that = this;
            var templates = document.querySelectorAll("template[is=dom-bind]");
            for (var i = 0; i < templates.length; i++) {
                if (!templates[i]._propertyEffects) {
                    return;
                }

                var keys = Object.keys(templates[i]._propertyEffects);
                keys.forEach(function(key) {
                    if (typeof templates[i][key] === "object") {
                        if (!templates[i][key].hasOwnProperty("$rootPath")) {
                            recursiveMarkObjProperties(that.obj, "");
                        }
                        if (templates[i][key].hasOwnProperty("$rootPath")) {
                            that.notifyTemplateDomBind(templates[i][key], sequence, templates[i], key);
                        }
                    }
                });
            }
        },
        onLocalChange: function(patches) {
            this.propagateDomBind(patches);
        },
        onPatchReceived: function(data, url, method) {
            this.fire("patchreceived", {
                data: data,
                url: url,
                method: method
            });
        },
        onPatchSent: function(data, url, method) {
            this.fire("patchsent", {
                data: data,
                url: url,
                method: method
            });
        },
        onSocketStateChanged: function(state, url, data, code, reason) {
            this.fire("socketstatechanged", {
                state: state,
                url: url,
                data: data,
                statusCode: code,
                reason: reason
            });
        },
        onConnectionError: function(data, url, method) {
            var eventDetail = {
                data: data,
                url: url,
                method: method,
                handled: false
            };

            this.fire("connectionerror", eventDetail);

            if (!eventDetail.handled) {
                alert("Connection error, please reload page!");
            }
        },
        applyJSONPatch: function(tree, sequence) {
            if (!this.bound) {
                var whereToBind = this.getAttribute("ref");
                if (whereToBind) {
                    this.bindTo(whereToBind);
                }
            }

            this.propagateDomBind(sequence);
            // FIXME tomalec: DRY, puppet does the same
            this.dispatchEvent(new CustomEvent("patch-applied", {
                bubbles: true,
                cancelable: true,
                detail: sequence
            }));
        },
        notifyTemplateDomBind: function(tree, sequence, templateDomBind, polymerPathPrefix) {
            var operation, polymerPath;
            for (var operationNo = 0, len = sequence.length; operationNo < len; operationNo++) {
                operation = sequence[operationNo];

                if (operation.path == "") {
                    //in case of root path, Polymer replaces the original obj, which detaches it from Puppet
                    var newSequence = [];
                    for (var prop in operation.value) {
                        if (operation.value.hasOwnProperty(prop)) {
                            newSequence.push({
                                op: "add",
                                path: "/" + prop,
                                value: operation.value[prop]
                            });
                        }
                    }
                    this.notifyTemplateDomBind(tree, newSequence, templateDomBind, polymerPathPrefix);
                    continue;
                }

                if (tree.$rootPath.length > 0 && operation.path.indexOf(tree.$rootPath) !== 0) {
                    //the path is out of scope of current templateDomBind
                    continue;
                }

                polymerPath = polymerPathPrefix + translateJSONPointerToPolymerPath(operation.path.substring(tree.$rootPath.length));

                if (operation.op === 'test') {
                    // we assume that jsonpatch covered it already
                } else if (operation.op === 'move' || operation.op === 'copy') {
                    console.warn("move, and copy operations are not supported yet.")
                } else {
                    // for add and remove we need to check whether it's an array or not
                    var lastSeparator = operation.path.lastIndexOf('/');
                    var name = operation.path.substr(lastSeparator + 1);
                    var parentsPolymerPath = polymerPathPrefix + translateJSONPointerToPolymerPath(operation.path.substring(tree.$rootPath.length, lastSeparator));

                    var parent = templateDomBind.get(parentsPolymerPath);
                    if (Array.isArray(parent) && (name === '-' || isNormalInteger(name))) {
                        switch (operation.op) {
                            case 'add':
                                // JSONPatch push
                                if (name === '-') {
                                    name = parent.length;
                                }
                                if (operation.$spliceIndex !== undefined) {
                                    templateDomBind.notifySplices(parentsPolymerPath, [{
                                        index: operation.$spliceIndex,
                                        removed: [],
                                        addedCount: 1,
                                        object: parent,
                                        type: 'splice'
                                    }]);
                                } else {
                                    operation.$spliceIndex = parseInt(name, 10);
                                    templateDomBind.splice(parentsPolymerPath, operation.$spliceIndex, 0, operation.value);
                                }
                                console.info('Add /splice in array is fragile, as Polymer requires something they call normalization, so splices to appear in index order, what is not guaranteed by this element.')

                                break;
                            case 'replace':

                                templateDomBind.splice(parentsPolymerPath, name, 1, operation.value);
                                break;
                                // addedCount = 1;
                                // var col = Polymer.Collection.get(parent);
                                // removed = col.getItem('#'+name);
                            case 'remove':
                                if (operation.$spliceIndex !== undefined) {
                                    templateDomBind.notifySplices(parentsPolymerPath, [{
                                        index: operation.$spliceIndex,
                                        removed: operation.$spliceRemoved,
                                        addedCount: 0,
                                        object: parent,
                                        type: 'splice'
                                    }]);
                                } else {
                                    operation.$spliceIndex = parseInt(name, 10);
                                    operation.$spliceRemoved = [parent[operation.$spliceIndex]];
                                    templateDomBind.splice(parentsPolymerPath, name, 1);
                                }

                                console.info('Remove is fragile, as Polymer requires something they call normalization, so splices to appear in index order, what is not guaranteed by this element.')
                                break;
                        }
                    } else {
                        switch (operation.op) {
                            case 'add':
                            case 'replace':
                                templateDomBind.set(polymerPath, operation.value);
                                // this.notifyPath(polymerPath, operation.value);
                                break;
                            case 'remove':
                                templateDomBind.set(polymerPath, null);
                                templateDomBind.set(polymerPath, undefined);
                                // this.notifyPath(polymerPath, undefined);
                                console.warn('Polymer does not support unsetting properties https://github.com/Polymer/polymer/issues/2565');
                                console.warn('remove is translated to JSON incompatible set to `undefined`, as there is no remove mathond in Polymer.')
                                break;
                        }
                    }
                }
            }
        },
        validateJSONPatch: function() {
            console.info('inherit  validateJSONPatch from fast-json-patch');
        },
        observeJSONPatch: function(obj, callback) {
            this.puppetObserver = callback;
            return callback;
        },
        unobserveJSONPatch: function() {
            // FIXME this is dummy as hell
            this.puppetObserver = noop;
        },
		_ignoreAddChanged: function(newVal, oldVal) {
			if (typeof this.ignoreAdd === "string") {
				this.ignoreAdd = new RegExp(this.ignoreAdd);
			}
		}

    });

    function noop() {}

    function translateJSONPointerToPolymerPath(pointer) {
        return pointer.replace(/\//g, '.');
    }

    function translatePolymerPathToJSONPointer(pointer) {
        return pointer.replace(/~/g, '~0')
            .replace(/\//g, '~1')
            .replace(/\./g, '/');
    }

    function isNormalInteger(str) {
        var n = ~~Number(str);
        return String(n) === str && n >= 0;
    }


    var _isArray;
    if (Array.isArray) {
        _isArray = Array.isArray;
    } else {
        _isArray = function(obj) {
            return obj.push && typeof obj.length === 'number';
        };
    }

    function placeMarker(subject, rootPath) {
        if (!subject.hasOwnProperty('$rootPath')) {
            Object.defineProperty(subject, '$rootPath', {
                enumerable: false,
                get: function() {
                    return rootPath;
                }
            });
        };
    }

    function recursiveMarkObjProperties(subject, rootPath) {
        if (subject !== null && typeof subject === 'object') {
            placeMarker(subject, rootPath);
            for (var i in subject) {
                if (subject.hasOwnProperty(i)) {
                    recursiveMarkObjProperties(subject[i], rootPath + "/" + i);
                }
            }
        }
    }


}());
</script>
